
1. Create a new GitHub repository with the following structure:
  
terraform-repo/
├── main.tf

2. main.tf file content:

provider "local" {
  # The local provider doesn't require any configuration.
}

resource "local_file" "example" {
  filename = "${path.module}/example.txt"
  content  = "This is an example file created by Terraform."
}

3.Push the configuration to your repository at https://github.com/example/terraform-repo in the main branch.

CRD Configuration
4 Ensure your spec.gitRepo.url points to the above repository 
and the branch is set to main. Update the containerRegistry.imageName

Testing
Ensure your controller is running and configured correctly.

Apply the CRD to your Kubernetes cluster:


kubectl apply -f <path-to-your-crd-file>.yaml
Verify the output:

The apply script should run and create example.txt in the working directory of the controller.
You can check the logs of the controller pod to ensure the Terraform commands are executed successfully.


This simple Terraform configuration allows you to test the functionality of your custom resource definition 
and the controller without needing to authenticate with cloud-based services.

apiVersion: alustan.io/v1alpha1
kind: Terraform
metadata:
  name: example-terraformconfig
  namespace: default
spec:
  variables:
    var1: value1
    var2: value2
  backend:
    provider: local
    s3: ""
    dynamoDB: ""
    region: ""

  scripts:
    apply: 
      configMapRef:
        name: terraform-scripts
        key: apply-script.sh
    destroy:
      configMapRef:
        name: terraform-scripts
        key: destroy-script.sh

  gitRepo:
    url: https://github.com/example/terraform-repo
    branch: main

  containerRegistry:
    imageName: docker.io/alustan/terraform-controller
    secretRef:
      name: my-dockerhub-secret
      key: dockerhub-cred


Applying the CRD
Once the CRD is applied, your controller should clone the repository, 
execute the Terraform configuration, and create a local file named example.txt with the specified content.




# kubectl create configmap terraform-scripts --from-file=apply-script=apply_script.sh --from-file=destroy-script=destroy_script.sh
---
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: terraform-scripts
# data:
#   apply-script.sh: |
#     #!/bin/bash
#     echo "This is the apply script"
#   destroy-script.sh: |
#     #!/bin/bash
#     echo "This is the destroy script"


# kubectl create secret docker-registry my-registry-secret \
#   --docker-server=https://index.docker.io/v1/ \
#   --docker-username=<USERNAME> \
#   --docker-password=<PASSWORD> \
#   --docker-email=<EMAIL>


apiVersion: alustan.io/v1alpha1
kind: Terraform
metadata:
  name: example-terraformconfig
  namespace: default
spec:
  variables:
    var1: value1
    var2: value2
  backend:
    provider: aws
    s3: s3-store
    dynamoDB: db-table
    region: us-east-1
  scripts:
    apply: 
     inline: |
       terraform apply -auto-approve
    destroy: 
     inline: |
        terraform destroy -auto-approve
  gitRepo:
    url: git@github.com:example/terraform-repo
    branch: main
    sshKeySecret:
      name: my-ssh-secret
      key: ssh-privatekey
  containerRegistry:
    imageName: docker.io/alustan/terrform (image name to be built and push by the controller)
    secretRef:
      name: my-dockerhub-secret
      key: dockerhub-cred


kaniko

{
  "auths": {
    "https://index.docker.io/v1/": {
      "username": "alustan",
      "password": "dckr_pat_***************",
      "email": "alustanplatform@gmail.com",
      "auth": "base64(username:password)"
    }
  }
}
alternatively

docker login -u alustan --password-stdin dckr_pat_***************
cat ~/.docker/config.json

base64 -w 0 <path-to-dockerconfigjson>

cat docker-config.json | base64 -w 0




apiVersion: v1
kind: Secret
metadata:
  name: alustankanikosecret
  namespace: default # Change this to your desired namespace
data:
  .dockerconfigjson: <base64-encoded-docker-config-json>
type: kubernetes.io/dockerconfigjson

apiVersion: v1
kind: Secret
metadata:
  name: alustankanikosecret
  namespace: default
data:
  .dockerconfigjson: eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsia
m9ic2RvY2tlci51c2VybmFtZSI6ImFsdXN0YW4iLCJwYXNzd29yZCI6ImRja3JfcGF0X21vZXNDS
C14dnVYSFRTV3J6TXlOVzVMa1ZrayIsZvcm1AZ21haWwuY29tImF1dGgiOiJBV0RkY2tyX3BhdF9tb2VzQ0gs9In19fQ==

type: kubernetes.io/dockerconfigjson


kubectl logs docker-run-pod -n <namespace>

kubectl create secret docker-registry my-docker-secret \
  --docker-username=YOUR_DOCKER_USERNAME \
  --docker-password=YOUR_DOCKER_PASSWORD \
  --docker-email=YOUR_DOCKER_EMAIL \
  --docker-server=https://index.docker.io/v1/








